/**
   $Id:$

   gLCD library!

   Copyright (C) 2010 Limor Fried, Adafruit Industries

   This library is free software; you can redistribute it and/or modify it under
   the terms of the  GNU Lesser General Public License as  published by the Free
   Software Foundation; either  version 2.1 of the License, or  (at your option)
   any later version.

   This library is distributed  in the hope that it will  be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
   FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
   details.

   You should  have received  a copy  of the GNU  Lesser General  Public License
   along with this library; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/

/**
   Modifications
   - 08/2014 This files has been modified for the need of the libavrc++ by
   netWorms
 */

#ifndef __GLCD_HH__
#define __GLCD_HH__

#include "common/common.hh"
#include <avr/pgmspace.h>
#include <stdlib.h>
#include <string.h>

template <class hw_lcd, bool partial_update = hw_lcd::partial_update>

struct gLCDBoundingBox {
  gLCDBoundingBox() { clear(); }

  void clear() {
    x_min = hw_lcd::width - 1;
    y_min = hw_lcd::height - 1;

    x_max = 0;
    y_max = 0;
  }

  void update(uint8_t x, uint8_t y) {
    x_min = std::min(x, x_min);
    y_min = std::min(y, y_min);

    x_max = std::min(std::max(x, x_max), hw_lcd::width - 1);
    y_max = std::min(std::max(y, y_max), hw_lcd::height - 1);
  }

  void update(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2) {
    x_min = std::max(std::min(x1, x_min), 0u);
    y_min = std::max(std::min(y1, y_min), 0u);

    x_max = std::min(std::max(x2, x_max), hw_lcd::width - 1);
    y_max = std::min(std::max(y2, y_max), hw_lcd::height - 1);
  }

  uint8_t x_min, x_max, y_min, y_max;
};

template <class hw_lcd> struct gLCDBoundingBox<hw_lcd, false> {
  gLCDBoundingBox() { clear(); }

  void clear() {
    x_min = 0;
    y_min = 0;

    x_max = hw_lcd::width - 1;
    y_max = hw_lcd::height - 1;
  }

  void update(uint8_t, uint8_t) {}
  void update(uint8_t, uint8_t, uint8_t, uint8_t) {}

  uint8_t x_min, x_max, y_min, y_max;
};

/* -------------------------------------------------------------------------- */
template <class hw_lcd> class gLCD : public hw_lcd {
public:
  static void activate() {
    hw_lcd::activate();
    hw_lcd::setBrightness(0x18);
    clear();
  }

  /* ------------------------------------------------------------------------ */
  static void clear() {
    memset(buffer, 0, hw_lcd::height * hw_lcd::width / 8);
    bbox.update(0, 0, hw_lcd::width - 1, hw_lcd::height - 1);
    display();
  }

  /* ------------------------------------------------------------------------ */
  static void setPixel(uint8_t x, uint8_t y, uint8_t color = 0x1) {
    setPixelWhithoutBBUpdate(x, y, color);
    bbox.update(x, y);
  }

  /* ------------------------------------------------------------------------ */
  static void print(uint8_t x, uint8_t y, uint8_t c) {
    if (x + 6 > hw_lcd::width || y + 8 > hw_lcd::height)
      return;

    drawBitmap_PF(x, y, font[c], 5, 8, true);

    drawLine(x + 5, y, x + 5, y + 7, 0x00);
    bbox.update(x, y, x + 5, y + 7);
  }

  static void print(uint8_t x, uint8_t y, const char *str) {
    uint8_t _x = x;
    uint8_t _y = y;
    for (const char *s = str; *s != 0; ++s) {
      print(_x, _y, *s);

      _x += 6;
      _y += (_x / hw_lcd::width) * 8;
      _x = _x % hw_lcd::width;
    }
  }

  static void printf(uint8_t x, uint8_t y, const char *format, ...) {
    va_list va_arg_lst;
#define MAX_STR_SIZE 64
    char str[MAX_STR_SIZE];

    va_start(va_arg_lst, format);
    vsnprintf(str, MAX_STR_SIZE, format, va_arg_lst);
    va_end(va_arg_lst);

    print(x, y, str);
  }

  /* ------------------------------------------------------------------------ */
  static void drawBitmap(uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t w,
                         uint8_t h, uint8_t color = 0x1) {
    for (uint8_t j = 0; j < h; ++j) {
      for (uint8_t i = 0; i < w; ++i) {
        uint8_t color = bitmap[i + (j / 8) * w] & _BV(j % 8);
        setPixelWhithoutBBUpdate(x + i, y + j, color);
      }
    }

    bbox.update(x, y, x + w, y + h);
  }

  /* ------------------------------------------------------------------------ */
  static void drawBitmap_PF(uint8_t x, uint8_t y, const uint8_t *bitmap,
                            uint8_t w, uint8_t h, bool flip = false) {
    for (uint8_t j = 0; j < h; ++j) {
      for (uint8_t i = 0; i < w; ++i) {
        uint8_t mask;
        if (flip)
          mask = _BV(7 - j % 8);
        else
          mask = _BV(j % 8);
        uint8_t color = pgm_read_byte(bitmap + i + (j / 8) * w) & mask;
        setPixelWhithoutBBUpdate(x + i, y + j, color);
      }
    }

    bbox.update(x, y, x + w, y + h);
  }

  /* ------------------------------------------------------------------------ */
  static void drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1,
                       uint8_t color = 0x1) {
    uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
    if (steep) {
      std::swap(x0, y0);
      std::swap(x1, y1);
    }

    if (x0 > x1) {
      std::swap(x0, x1);
      std::swap(y0, y1);
    }

    // much faster to put the test here, since we've already sorted the points
    bbox.update(x0, y0, x1, y1);

    uint8_t dx, dy;
    dx = x1 - x0;
    dy = abs(y1 - y0);

    int8_t err = dx / 2;
    int8_t ystep;

    if (y0 < y1) {
      ystep = 1;
    } else {
      ystep = -1;
    }

    for (; x0 <= x1; x0++) {
      if (steep) {
        setPixelWhithoutBBUpdate(y0, x0, color);
      } else {
        setPixelWhithoutBBUpdate(x0, y0, color);
      }
      err -= dy;
      if (err < 0) {
        y0 += ystep;
        err += dx;
      }
    }
  }

  /* ------------------------------------------------------------------------ */
  static void drawRectangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2,
                            uint8_t color = 0x1, bool filled = false) {
    // drawLine(x1, y1, x1, y2, color);
    // drawLine(x1, y1, x2, y1, color);
    // drawLine(x2, y1, x2, y2, color);
    // drawLine(x1, y2, x2, y2, color);

    for (uint8_t i = x1; i <= x2; ++i) {
      setPixelWhithoutBBUpdate(i, y1, color);
      setPixelWhithoutBBUpdate(i, y2, color);
    }

    for (uint8_t j = y1; j <= y2; ++j) {
      setPixelWhithoutBBUpdate(x1, j, color);
      setPixelWhithoutBBUpdate(x2, j, color);
    }

    if (filled) {
      for (uint8_t i = x1 + 1; i <= x2 - 1; ++i) {
        for (uint8_t j = y1 + 1; j <= y2 - 1; ++j) {
          setPixelWhithoutBBUpdate(i, j, color);
        }
      }
    }

    bbox.update(x1, y1, x2, y2);
  }

  /* ------------------------------------------------------------------------ */
  static void drawCircle(uint8_t x0, uint8_t y0, uint8_t r, uint8_t color = 0x1,
                         bool filled = false) {
    int8_t f = 1 - r;
    int8_t ddF_x = 1;
    int8_t ddF_y = -2 * r;
    int8_t x = 0;
    int8_t y = r;

    setPixelWhithoutBBUpdate(x0, y0 + r, color);
    setPixelWhithoutBBUpdate(x0, y0 - r, color);
    setPixelWhithoutBBUpdate(x0 + r, y0, color);
    setPixelWhithoutBBUpdate(x0 - r, y0, color);

    if (filled) {
      for (uint8_t i = y0 - r + 1; i <= y0 + r - 1; i++) {
        setPixelWhithoutBBUpdate(x0, i, color);
      }
    }

    while (x < y) {
      if (f >= 0) {
        y--;
        ddF_y += 2;
        f += ddF_y;
      }
      x++;
      ddF_x += 2;
      f += ddF_x;

      setPixelWhithoutBBUpdate(x0 + x, y0 + y, color);
      setPixelWhithoutBBUpdate(x0 - x, y0 + y, color);
      setPixelWhithoutBBUpdate(x0 + x, y0 - y, color);
      setPixelWhithoutBBUpdate(x0 - x, y0 - y, color);

      setPixelWhithoutBBUpdate(x0 + y, y0 + x, color);
      setPixelWhithoutBBUpdate(x0 - y, y0 + x, color);
      setPixelWhithoutBBUpdate(x0 + y, y0 - x, color);
      setPixelWhithoutBBUpdate(x0 - y, y0 - x, color);

      if (filled) {
        for (uint8_t i = y0 - y + 1; i <= y0 + y - 1; ++i) {
          setPixelWhithoutBBUpdate(x0 + x, i, color);
          setPixelWhithoutBBUpdate(x0 - x, i, color);
        }

        for (uint8_t i = y0 - x + 1; i <= y0 + x - 1; ++i) {
          setPixelWhithoutBBUpdate(x0 + y, i, color);
          setPixelWhithoutBBUpdate(x0 - y, i, color);
        }
      }
    }

    bbox.update(x0 - r, y0 - r, x0 + r, y0 + r);
  }

  /* ------------------------------------------------------------------------ */
  static void display() {
    hw_lcd::display(buffer, bbox.x_min, bbox.y_min, bbox.x_max, bbox.y_max);
    bbox.clear();
  }

private:
  static void setPixelWhithoutBBUpdate(uint8_t x, uint8_t y,
                                       uint8_t color = 0x1) {
    if ((x >= hw_lcd::width) || (y >= hw_lcd::height))
      return;

    if (color)
      buffer[x + (y / (hw_lcd::height / 8)) * hw_lcd::width] |=
          _BV(7 - (y % 8));
    else
      buffer[x + (y / (hw_lcd::height / 8)) * hw_lcd::width] &=
          ~_BV(7 - (y % 8));
  }

  static uint8_t buffer[hw_lcd::width * hw_lcd::height / 8];
  static const uint8_t font[][5] PROGMEM;

  static gLCDBoundingBox<hw_lcd> bbox;
};

template <typename hw_lcd>
uint8_t gLCD<hw_lcd>::buffer[hw_lcd::width * hw_lcd::height / 8] = {0x00};

template <typename hw_lcd> gLCDBoundingBox<hw_lcd> gLCD<hw_lcd>::bbox;

template <typename hw_lcd>
const uint8_t gLCD<hw_lcd>::font[][5] PROGMEM = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 00
    {0x7C, 0xDA, 0xF2, 0xDA, 0x7C}, // 01
    {0x7C, 0xD6, 0xF2, 0xD6, 0x7C}, // 02
    {0x38, 0x7C, 0x3E, 0x7C, 0x38}, // 03
    {0x18, 0x3C, 0x7E, 0x3C, 0x18}, // 04
    {0x38, 0xEA, 0xBE, 0xEA, 0x38}, // 05
    {0x38, 0x7A, 0xFE, 0x7A, 0x38}, // 06
    {0x00, 0x18, 0x3C, 0x18, 0x00}, // 07
    {0xFF, 0xE7, 0xC3, 0xE7, 0xFF}, // 08
    {0x00, 0x18, 0x24, 0x18, 0x00}, // 09
    {0xFF, 0xE7, 0xDB, 0xE7, 0xFF}, // 0A
    {0x0C, 0x12, 0x5C, 0x60, 0x70}, // 0B
    {0x64, 0x94, 0x9E, 0x94, 0x64}, // 0C
    {0x02, 0xFE, 0xA0, 0xA0, 0xE0}, // 0D
    {0x02, 0xFE, 0xA0, 0xA4, 0xFC}, // 0E
    {0x5A, 0x3C, 0xE7, 0x3C, 0x5A}, // 0F
    {0xFE, 0x7C, 0x38, 0x38, 0x10}, // 10
    {0x10, 0x38, 0x38, 0x7C, 0xFE}, // 11
    {0x28, 0x44, 0xFE, 0x44, 0x28}, // 12
    {0xFA, 0xFA, 0x00, 0xFA, 0xFA}, // 13
    {0x60, 0x90, 0xFE, 0x80, 0xFE}, // 14
    {0x00, 0x66, 0x91, 0xA9, 0x56}, // 15
    {0x06, 0x06, 0x06, 0x06, 0x06}, // 16
    {0x29, 0x45, 0xFF, 0x45, 0x29}, // 17
    {0x10, 0x20, 0x7E, 0x20, 0x10}, // 18
    {0x08, 0x04, 0x7E, 0x04, 0x08}, // 19
    {0x10, 0x10, 0x54, 0x38, 0x10}, // 1A
    {0x10, 0x38, 0x54, 0x10, 0x10}, // 1B
    {0x78, 0x08, 0x08, 0x08, 0x08}, // 1C
    {0x30, 0x78, 0x30, 0x78, 0x30}, // 1D
    {0x0C, 0x1C, 0x7C, 0x1C, 0x0C}, // 1E
    {0x60, 0x70, 0x7C, 0x70, 0x60}, // 1F
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 20 space
    {0x00, 0x00, 0xFA, 0x00, 0x00}, // 21 !
    {0x00, 0xE0, 0x00, 0xE0, 0x00}, // 22 "
    {0x28, 0xFE, 0x28, 0xFE, 0x28}, // 23 #
    {0x24, 0x54, 0xFE, 0x54, 0x48}, // 24 $
    {0xC4, 0xC8, 0x10, 0x26, 0x46}, // 25 %
    {0x6C, 0x92, 0x6A, 0x04, 0x0A}, // 26 &
    {0x00, 0x10, 0xE0, 0xC0, 0x00}, // 27 '
    {0x00, 0x38, 0x44, 0x82, 0x00}, // 28 (
    {0x00, 0x82, 0x44, 0x38, 0x00}, // 29 )
    {0x54, 0x38, 0xFE, 0x38, 0x54}, // 2a *
    {0x10, 0x10, 0x7C, 0x10, 0x10}, // 2b +
    {0x00, 0x01, 0x0E, 0x0C, 0x00}, // 2c ,
    {0x10, 0x10, 0x10, 0x10, 0x10}, // 2d -
    {0x00, 0x00, 0x06, 0x06, 0x00}, // 2e .
    {0x04, 0x08, 0x10, 0x20, 0x40}, // 2f /
    {0x7C, 0x8A, 0x92, 0xA2, 0x7C}, // 30 0
    {0x00, 0x42, 0xFE, 0x02, 0x00}, // 31 1
    {0x4E, 0x92, 0x92, 0x92, 0x62}, // 32 2
    {0x84, 0x82, 0x92, 0xB2, 0xCC}, // 33 3
    {0x18, 0x28, 0x48, 0xFE, 0x08}, // 34 4
    {0xE4, 0xA2, 0xA2, 0xA2, 0x9C}, // 35 5
    {0x3C, 0x52, 0x92, 0x92, 0x8C}, // 36 6
    {0x82, 0x84, 0x88, 0x90, 0xE0}, // 37 7
    {0x6C, 0x92, 0x92, 0x92, 0x6C}, // 38 8
    {0x62, 0x92, 0x92, 0x94, 0x78}, // 39 9
    {0x00, 0x00, 0x28, 0x00, 0x00}, // 3a :
    {0x00, 0x02, 0x2C, 0x00, 0x00}, // 3b ;
    {0x00, 0x10, 0x28, 0x44, 0x82}, // 3c <
    {0x28, 0x28, 0x28, 0x28, 0x28}, // 3d =
    {0x00, 0x82, 0x44, 0x28, 0x10}, // 3e >
    {0x40, 0x80, 0x9A, 0x90, 0x60}, // 3f ?
    {0x7C, 0x82, 0xBA, 0x9A, 0x72}, // 40 @
    {0x3E, 0x48, 0x88, 0x48, 0x3E}, // 41 A
    {0xFE, 0x92, 0x92, 0x92, 0x6C}, // 42 B
    {0x7C, 0x82, 0x82, 0x82, 0x44}, // 43 C
    {0xFE, 0x82, 0x82, 0x82, 0x7C}, // 44 D
    {0xFE, 0x92, 0x92, 0x92, 0x82}, // 45 E
    {0xFE, 0x90, 0x90, 0x90, 0x80}, // 46 F
    {0x7C, 0x82, 0x82, 0x8A, 0xCE}, // 47 G
    {0xFE, 0x10, 0x10, 0x10, 0xFE}, // 48 H
    {0x00, 0x82, 0xFE, 0x82, 0x00}, // 49 I
    {0x04, 0x02, 0x82, 0xFC, 0x80}, // 4a J
    {0xFE, 0x10, 0x28, 0x44, 0x82}, // 4b K
    {0xFE, 0x02, 0x02, 0x02, 0x02}, // 4c L
    {0xFE, 0x40, 0x38, 0x40, 0xFE}, // 4d M
    {0xFE, 0x20, 0x10, 0x08, 0xFE}, // 4e N
    {0x7C, 0x82, 0x82, 0x82, 0x7C}, // 4f O
    {0xFE, 0x90, 0x90, 0x90, 0x60}, // 50 P
    {0x7C, 0x82, 0x8A, 0x84, 0x7A}, // 51 Q
    {0xFE, 0x90, 0x98, 0x94, 0x62}, // 52 R
    {0x64, 0x92, 0x92, 0x92, 0x4C}, // 53 S
    {0xC0, 0x80, 0xFE, 0x80, 0xC0}, // 54 T
    {0xFC, 0x02, 0x02, 0x02, 0xFC}, // 55 U
    {0xF8, 0x04, 0x02, 0x04, 0xF8}, // 56 V
    {0xFC, 0x02, 0x1C, 0x02, 0xFC}, // 57 W
    {0xC6, 0x28, 0x10, 0x28, 0xC6}, // 58 X
    {0xC0, 0x20, 0x1E, 0x20, 0xC0}, // 59 Y
    {0x86, 0x9A, 0x92, 0xB2, 0xC2}, // 5a Z
    {0x00, 0xFE, 0x82, 0x82, 0x82}, // 5b [
    {0x40, 0x20, 0x10, 0x08, 0x04}, // 5c backspace
    {0x00, 0x82, 0x82, 0x82, 0xFE}, // 5d ]
    {0x20, 0x40, 0x80, 0x40, 0x20}, // 5e ]
    {0x02, 0x02, 0x02, 0x02, 0x02}, // 5f _
    {0x00, 0xC0, 0xE0, 0x10, 0x00}, // 60 `
    {0x04, 0x2A, 0x2A, 0x1E, 0x02}, // 61 a
    {0xFE, 0x14, 0x22, 0x22, 0x1C}, // 62 b
    {0x1C, 0x22, 0x22, 0x22, 0x14}, // 63 c
    {0x1C, 0x22, 0x22, 0x14, 0xFE}, // 64 d
    {0x1C, 0x2A, 0x2A, 0x2A, 0x18}, // 65 e
    {0x00, 0x10, 0x7E, 0x90, 0x40}, // 66 f
    {0x18, 0x25, 0x25, 0x39, 0x1E}, // 67 g
    {0xFE, 0x10, 0x20, 0x20, 0x1E}, // 68 h
    {0x00, 0x22, 0xBE, 0x02, 0x00}, // 69 i
    {0x04, 0x02, 0x02, 0xBC, 0x00}, // 6a j
    {0xFE, 0x08, 0x14, 0x22, 0x00}, // 6b k
    {0x00, 0x82, 0xFE, 0x02, 0x00}, // 6c l
    {0x3E, 0x20, 0x1E, 0x20, 0x1E}, // 6d m
    {0x3E, 0x10, 0x20, 0x20, 0x1E}, // 6e n
    {0x1C, 0x22, 0x22, 0x22, 0x1C}, // 6f o
    {0x3F, 0x18, 0x24, 0x24, 0x18}, // 70 p
    {0x18, 0x24, 0x24, 0x18, 0x3F}, // 71 q
    {0x3E, 0x10, 0x20, 0x20, 0x10}, // 72 r
    {0x12, 0x2A, 0x2A, 0x2A, 0x24}, // 73 s
    {0x20, 0x20, 0xFC, 0x22, 0x24}, // 74 t
    {0x3C, 0x02, 0x02, 0x04, 0x3E}, // 75 u
    {0x38, 0x04, 0x02, 0x04, 0x38}, // 76 v
    {0x3C, 0x02, 0x0C, 0x02, 0x3C}, // 77 w
    {0x22, 0x14, 0x08, 0x14, 0x22}, // 78 x
    {0x32, 0x09, 0x09, 0x09, 0x3E}, // 79 y
    {0x22, 0x26, 0x2A, 0x32, 0x22}, // 7a z
    {0x00, 0x10, 0x6C, 0x82, 0x00}, // 7b {
    {0x00, 0x00, 0xEE, 0x00, 0x00}, // 7c |
    {0x00, 0x82, 0x6C, 0x10, 0x00}, // 7d }
    {0x40, 0x80, 0x40, 0x20, 0x40}, // 7e ~
    {0x3C, 0x64, 0xC4, 0x64, 0x3C}, // 7f DEL
    {0x78, 0x85, 0x85, 0x86, 0x48}, // 80
    {0x5C, 0x02, 0x02, 0x04, 0x5E}, // 81
    {0x1C, 0x2A, 0x2A, 0xAA, 0x9A}, // 82
    {0x84, 0xAA, 0xAA, 0x9E, 0x82}, // 83
    {0x84, 0x2A, 0x2A, 0x1E, 0x82}, // 84
    {0x84, 0xAA, 0x2A, 0x1E, 0x02}, // 85
    {0x04, 0x2A, 0xAA, 0x9E, 0x02}, // 86
    {0x30, 0x78, 0x4A, 0x4E, 0x48}, // 87
    {0x9C, 0xAA, 0xAA, 0xAA, 0x9A}, // 88
    {0x9C, 0x2A, 0x2A, 0x2A, 0x9A}, // 89
    {0x9C, 0xAA, 0x2A, 0x2A, 0x1A}, // 8a
    {0x00, 0x00, 0xA2, 0x3E, 0x82}, // 8b
    {0x00, 0x40, 0xA2, 0xBE, 0x42}, // 8c
    {0x00, 0x80, 0xA2, 0x3E, 0x02}, // 8d
    {0x0F, 0x94, 0x24, 0x94, 0x0F}, // 8e
    {0x0F, 0x14, 0xA4, 0x14, 0x0F}, // 8f
    {0x3E, 0x2A, 0xAA, 0xA2, 0x00}, // 90
    {0x04, 0x2A, 0x2A, 0x3E, 0x2A}, // 91
    {0x3E, 0x50, 0x90, 0xFE, 0x92}, // 92
    {0x4C, 0x92, 0x92, 0x92, 0x4C}, // 93
    {0x4C, 0x12, 0x12, 0x12, 0x4C}, // 94
    {0x4C, 0x52, 0x12, 0x12, 0x0C}, // 95
    {0x5C, 0x82, 0x82, 0x84, 0x5E}, // 96
    {0x5C, 0x42, 0x02, 0x04, 0x1E}, // 97
    {0x00, 0xB9, 0x05, 0x05, 0xBE}, // 98
    {0x9C, 0x22, 0x22, 0x22, 0x9C}, // 99
    {0xBC, 0x02, 0x02, 0x02, 0xBC}, // 9a
    {0x3C, 0x24, 0xFF, 0x24, 0x24}, // 9b
    {0x12, 0x7E, 0x92, 0xC2, 0x66}, // 9c
    {0xD4, 0xF4, 0x3F, 0xF4, 0xD4}, // 9d
    {0xFF, 0x90, 0x94, 0x6F, 0x04}, // 9e
    {0x03, 0x11, 0x7E, 0x90, 0xC0}, // 9f
    {0x04, 0x2A, 0x2A, 0x9E, 0x82}, // a0
    {0x00, 0x00, 0x22, 0xBE, 0x82}, // a1
    {0x0C, 0x12, 0x12, 0x52, 0x4C}, // a2
    {0x1C, 0x02, 0x02, 0x44, 0x5E}, // a3
    {0x00, 0x5E, 0x50, 0x50, 0x4E}, // a4
    {0xBE, 0xB0, 0x98, 0x8C, 0xBE}, // a5
    {0x64, 0x94, 0x94, 0xF4, 0x14}, // a6
    {0x64, 0x94, 0x94, 0x94, 0x64}, // a7
    {0x0C, 0x12, 0xB2, 0x02, 0x04}, // a8
    {0x1C, 0x10, 0x10, 0x10, 0x10}, // a9
    {0x10, 0x10, 0x10, 0x10, 0x1C}, // aa
    {0xF4, 0x08, 0x13, 0x35, 0x5D}, // ab
    {0xF4, 0x08, 0x14, 0x2C, 0x5F}, // ac
    {0x00, 0x00, 0xDE, 0x00, 0x00}, // ad
    {0x10, 0x28, 0x54, 0x28, 0x44}, // ae
    {0x44, 0x28, 0x54, 0x28, 0x10}, // af
    {0x00, 0x60, 0x90, 0x90, 0x60}, // b0//{ 0x55, 0x00, 0xAA, 0x00, 0x55 },
    {0x55, 0xAA, 0x55, 0xAA, 0x55}, // b1
    {0xAA, 0x55, 0xAA, 0x55, 0xAA}, // b2
    {0x00, 0x00, 0x00, 0xFF, 0x00}, // b3
    {0x08, 0x08, 0x08, 0xFF, 0x00}, // b4
    {0x28, 0x28, 0x28, 0xFF, 0x00}, // b5
    {0x08, 0x08, 0xFF, 0x00, 0xFF}, // b6
    {0x08, 0x08, 0x0F, 0x08, 0x0F}, // b7
    {0x28, 0x28, 0x28, 0x3F, 0x00}, // b8
    {0x28, 0x28, 0xEF, 0x00, 0xFF}, // b9
    {0x00, 0x00, 0xFF, 0x00, 0xFF}, // ba
    {0x28, 0x28, 0x2F, 0x20, 0x3F}, // bb
    {0x28, 0x28, 0xE8, 0x08, 0xF8}, // bc
    {0x08, 0x08, 0xF8, 0x08, 0xF8}, // bd
    {0x28, 0x28, 0x28, 0xF8, 0x00}, // be
    {0x08, 0x08, 0x08, 0x0F, 0x00}, // bf
    {0x00, 0x00, 0x00, 0xF8, 0x08}, // c0
    {0x08, 0x08, 0x08, 0xF8, 0x08}, // c1
    {0x08, 0x08, 0x08, 0x0F, 0x08}, // c2
    {0x00, 0x00, 0x00, 0xFF, 0x08}, // c3
    {0x08, 0x08, 0x08, 0x08, 0x08}, // c4
    {0x08, 0x08, 0x08, 0xFF, 0x08}, // c5
    {0x00, 0x00, 0x00, 0xFF, 0x28}, // c6
    {0x00, 0x00, 0xFF, 0x00, 0xFF}, // c7
    {0x00, 0x00, 0xF8, 0x08, 0xE8}, // c8
    {0x00, 0x00, 0x3F, 0x20, 0x2F}, // c9
    {0x28, 0x28, 0xE8, 0x08, 0xE8}, // ca
    {0x28, 0x28, 0x2F, 0x20, 0x2F}, // cb
    {0x00, 0x00, 0xFF, 0x00, 0xEF}, // cc
    {0x28, 0x28, 0x28, 0x28, 0x28}, // cd
    {0x28, 0x28, 0xEF, 0x00, 0xEF}, // ce
    {0x28, 0x28, 0x28, 0xE8, 0x28}, // cf
    {0x08, 0x08, 0xF8, 0x08, 0xF8}, // d0
    {0x28, 0x28, 0x28, 0x2F, 0x28}, // d1
    {0x08, 0x08, 0x0F, 0x08, 0x0F}, // d2
    {0x00, 0x00, 0xF8, 0x08, 0xF8}, // d3
    {0x00, 0x00, 0x00, 0xF8, 0x28}, // d4
    {0x00, 0x00, 0x00, 0x3F, 0x28}, // d5
    {0x00, 0x00, 0x0F, 0x08, 0x0F}, // d6
    {0x08, 0x08, 0xFF, 0x08, 0xFF}, // d7
    {0x28, 0x28, 0x28, 0xFF, 0x28}, // d8
    {0x08, 0x08, 0x08, 0xF8, 0x00}, // d9
    {0x00, 0x00, 0x00, 0x0F, 0x08}, // da
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // db
    {0x0F, 0x0F, 0x0F, 0x0F, 0x0F}, // dc
    {0xFF, 0xFF, 0xFF, 0x00, 0x00}, // dd
    {0x00, 0x00, 0x00, 0xFF, 0xFF}, // de
    {0xF0, 0xF0, 0xF0, 0xF0, 0xF0}, // df
    {0x1C, 0x22, 0x22, 0x1C, 0x22}, // e0
    {0x3E, 0x54, 0x54, 0x7C, 0x28}, // e1
    {0x7E, 0x40, 0x40, 0x60, 0x60}, // e2
    {0x40, 0x7E, 0x40, 0x7E, 0x40}, // e3
    {0xC6, 0xAA, 0x92, 0x82, 0xC6}, // e4
    {0x1C, 0x22, 0x22, 0x3C, 0x20}, // e5
    {0x02, 0x7E, 0x04, 0x78, 0x04}, // e6
    {0x60, 0x40, 0x7E, 0x40, 0x40}, // e7
    {0x99, 0xA5, 0xE7, 0xA5, 0x99}, // e8
    {0x38, 0x54, 0x92, 0x54, 0x38}, // e9
    {0x32, 0x4E, 0x80, 0x4E, 0x32}, // ea
    {0x0C, 0x52, 0xB2, 0xB2, 0x0C}, // eb
    {0x0C, 0x12, 0x1E, 0x12, 0x0C}, // ec
    {0x3D, 0x46, 0x5A, 0x62, 0xBC}, // ed
    {0x7C, 0x92, 0x92, 0x92, 0x00}, // ee
    {0x7E, 0x80, 0x80, 0x80, 0x7E}, // ef
    {0x54, 0x54, 0x54, 0x54, 0x54}, // f0
    {0x22, 0x22, 0xFA, 0x22, 0x22}, // f1
    {0x02, 0x8A, 0x52, 0x22, 0x02}, // f2
    {0x02, 0x22, 0x52, 0x8A, 0x02}, // f3
    {0x00, 0x00, 0xFF, 0x80, 0xC0}, // f4
    {0x07, 0x01, 0xFF, 0x00, 0x00}, // f5
    {0x10, 0x10, 0xD6, 0xD6, 0x10}, // f6
    {0x6C, 0x48, 0x6C, 0x24, 0x6C}, // f7
    {0x60, 0xF0, 0x90, 0xF0, 0x60}, // f8
    {0x00, 0x00, 0x18, 0x18, 0x00}, // f9
    {0x00, 0x00, 0x08, 0x08, 0x00}, // fa
    {0x0C, 0x02, 0xFF, 0x80, 0x80}, // fb
    {0x00, 0xF8, 0x80, 0x80, 0x78}, // fc
    {0x00, 0x98, 0xB8, 0xE8, 0x48}, // fd
    {0x00, 0x3C, 0x3C, 0x3C, 0x3C}, // fe
};

#endif // __GLCD_HH__
